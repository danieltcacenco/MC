{
  "laborator": [
    {
      "title": "Lucrare de laborator Nr.1",
      "laboratorTitle" : "Metoda substitutiei",
                
                "info" : "Operatia de cifrare se bazeaza pe o corespondenta biunivoca intre alfabetul clar si alfabetul cifrat. Se presupune ca alfabetul clar este format din cele 26 de litere (in limba romana fara diacritice) plus delimitatorul de cuvant spatiul. Alfabetul cifrat poate fi format din aceelea si caractere sau doar din cele 26 de litere (ale limbii romane) caz in care spatiul se va inlocui cu cea mai putin frecventa litera (Q) sau se va ignora pur si simplu. In continuare, delimitatorul de cuvant este inlocuit cu litera Q. Corespondenta dintre cele doua alfabete poate fi:\n\n- aleatoare\n-pseudoaleatoare: plecand de la o parola se construieste alfabetul cifrat.\n\nIntrucat in cazul corespondentei aleatoare lucrurile sunt cat se poate de clare, vom prezenta pe scurt o metoda de constructie a corespondentei in cel de- al doilea caz. Pornind de la o parola, alfabetul cifrat este construit dupa urmatorul algoritm:\n\n- se scriu, o singura data, in ordinea aparitiei, literele din parola;\n- se scriu literele alfabetului care nu apar in parola.\n\nCorespondenta intre cele doua alfabete se realizeaza dupa regula alfabet in alfabet dupa o permutare fixa æ (aceasta poate fi chiar permutarea identica iar la descifrare se aplica aceelasi procedeu doar cu inversa permutarii æ).\n\nIn functie de forma permutarii substitutia se numeste:\n\n- Directa (alfabetul cifrat are acelasi sens lexicografic cu alfabetul clar, sunt in total 26 astfel de substitutii).\n- Inversa (alfabetul cifrat are sens invers lexicografic cu alfabetul clar, sunt ın total 26 de astfel de substitutii).\nCifrurile de substitu ̧tie sunt cele mai utilizate sisteme de criptare simetrice; ele se întâlnesc și azi, exemple fiind sistemele DES și AES.\nUn astfel de cifru constă în înlocuirea fiecărui caracter din V cu alt caracter (din W ). Există două clase mari de cifruri de substituție: sisteme monoalfabetice și polialfabetice.\nUn astfel de sistem substituie fiecare caracter cu alt caracter – totdeauna același, indiferent de poziție. Atunci cînd cele două alfabete coincid (V = W), sistemele monoalfabetice sunt cazuri particulare de cifruri de permutare.\n\nSistemul de criptare Cezar\nSistemul de criptare Cezar este un sistem monoalfabetic: odată stabilită cheia de criptare eK , fiecare caracter cod x se înlocuiește prin caracterul cod x + k (mod 26)\nDecriptarea se realizează după formula dK (x) = x − k (mod 26).\nEvident, Cezar este un sistem generat de permutările ciclice din P26. Fiind numai 26 chei posibile, el este extrem de vulnerabil la atacul prin forță brută. Pentru a-i mări rezistența, s-a utilizat și o variantă, numită sistem Cezar cu cheie, definită astfel:\nSe consideră un cuvânt (cheie), preferabil cu toate caracterele distincte (în caz contrar, literele identice se folosesc doar la prima apari ̧tie). Acest cuvânt se așează la începutul al- fabetului. După ce se termină, șirul de completează cu literele care nu existau în cuvântul cheie, în ordine alfabetică\nDe exemplu, să presupunem că s-a ales cuvântul cheie MARTOR. Scriem:\nABCDEFGHIJKLMNOPQRSTUVWXYZ\nMARTOBCDEFGHIJKLNPQSUVWXYZ\nPentru textul clar se vor folosi caracterele de pe primul rând, iar pentru criptare – caracterele corespondente de pe rândul al doilea. Astfel, STUDENT se criptează în QSUTOJS, ARGINT în MPCEJS etc..\nSistemul Cezar cu cheie rezistă mai bine la atacul cu forță brută, numărul cheilor fiind acum card(P26 = 26!.",
                "imagine" : "cezar",
     
    
                },
    {
      "title": "Lucrare de laborator Nr.2",
      "laboratorTitle" : "Algoritmi de criptare polialfabetică",
                "info" : "Cifrul Vigenère este o metodă de criptare care folosește o serie de cifruri Cezar diferite bazate pe literele unui cuvânt-cheie. Este o formă simplă de substituție polialfabetică.\n\nCifrul Vigenère a fost reinventat de multe ori. Metoda a fost descrisă inițial de către Giovan Batista Belaso în 1553, în cartea sa La cifra del. Sig. Giovan Batista Belaso; totuși, schema a fost atribuită greșit mai târziu lui Blaise de Vigenère în secolul al XIX-lea, și este cunoscută acuma ca 'cifrul Vigenère'.\n\nAcest cifru este cunoscut deoarece deși este ușor de înțeles și implementat, pare pentru începători imposibil de spart; acestui fapt i se datorează descrierea le chiffre indéchiffrable (franceză, 'cifrul indescifrabil').\nLa fel ca cifrul Cezar, cifrul Vigenere deplasează literele, dar, spre deosebire de acesta nu se poate sparge uşor în 26 combinaţii. Cifrul Vigenere foloseşte o deplasare multiplă. Cheia nu este constituită de o singură deplasare, ci de mai multe. Cheia este constituită din câţiva întregi k i,unde 0 ≤k i≤ 25.  Aceşti întregi pot fi, de exemplu, ,k = (21, 4, 2 19, 14, 17). Această cheie ar provoca deplasare primei litere cu 21, c1 = p1 + 21 (mod 26), a celei de a doua cu 4, c2 = p2 + 4 (mod 26), ş.a.m.d. până la sfârşitul cheii şi apoi de la început, din nou. Cheia este de obicei un cvuvânt, pentru a fi mia uşor de memorat – cheia de mai sus corespunde cuvântului 'vector'. Metoda cu deplasare multiplă oferă protecţie suplimentară din două motive. Primul motiv este că ceilalţi nu cunosc lungimea cheii. Cel de al doilea este că numărul de soluţii posibile creşte. De exemplu, pentru lungimea cheii = 5, numărul de combinaţii care ar fi necesare la căutare exhaustivă ar fi 265= 11,881,376. Cifrul Vigenere a fost spart folosind altceva decât forţa brută (vezi mai jos). Un exemplu de cifru Vigenere:\nTextul clar:\nThis is an example of the Vigenere Cipher\nCheia:\nvector\nTextul cifrat:\nolklwjvrgqodkpghtkcixbuviitxqzklgk\n\nDecriptarea\n\nMetoda de descifrare folosită pentru cifrul Vigenere este asemănătoare metodei de cifrare. Diferenţa constă în faptul că se scade cheia din textul cifrat,pi = ci - ki (mod 26)\nTextul cifrat:\nolklwjvrgqodkpghtkcixbuviitxqzklgk\nCheia:\nvector\nTextul clar:\nthisisanexampleoftheVigenerecifrul\n\nTot ce rămâne de făcut este să se insereze spaţiile la locul potrivit...\n Mai jos este dat un exemplu:\n În consecință, mulți oameni au încercat să implementeze scheme de criptare care sunt, esențialmente, cifruri Vigenère, doar ca să fie sparte.Pentru a 2-a sarcina se foloseste un LFSR, care presupune generarea unui sir pseudoaleator. Fiecare bit este repozitionat cu o pozitie la dreapta iar ultimul bit din cuvint se foloseste la operatia xor cu un bit la alegere din cuvint si este plasat in frutnea cuvintului, asa cum este aratat în figura de mai jos.",
      "imagine" : "Untitled1",
                
    },
    {
      "title": "Lucrare de laborator Nr.3",
      "laboratorTitle" : "Criptarea simetrica, criptarea pe bloc",
                "info" : " Criptare pe bloc\n\nDefiniție Un cifru bloc pe n biți este o funcție  E :Vn•K → Vn astfel inversabilă (funcția de cifrare cu ajutorul cheii k ) din Vn în Vn. Funcția inversă este funcția de descifrare.\n\nExistă două moduri principale de utilizare în practică a algoritmilor simetrici: cifrarea bloc și cifrarea secvențială. Cifrarea bloc operează cu blocuri de text clar și cifrat-de regulă de 64 de biți, uneori chiar mai mari. Cifrarea secvențială operează cu secvențe de text clar și cifrat de un bit sau octet. În cazul cifrării bloc, același bloc de text clar va fi cifrat de fiecare dată în același bloc de text cifrat, folosind aceeași cheie. În cazul cifrării secvențiale, secvențele similare de text clar vor fi cifrate diferit în cazul unor cifrări repetate.\n\nModul CBC (cipher-block chaining)\nAcest mod folosește un mecanism feedback, deoarece rezultatul cifrării unui bloc anterior revine prin buclă și intervine în cifrarea blocului curent. Cu alte cuvinte, blocul anterior este folosit pentru a modifica cifrarea următorului bloc. În acest fel, textul cifrat nu mai depinde doar de textul clar, ciși de modul de cifrare al blocului anterior. În modul CBC, textul clar, înainte de a intra în modul de cifrare propriu-zis, este însumat mod 2 cu blocul de text cifrat anterior.\n\nIntrare: Cheia K pe k biți, vectorul inițial IV de n biți, mesajul clar\nM = M1,...,Mt pe blocuri de n biți. Ieșire: Textul cifrat C = C1, . . . , Ct care ulterior se descifrează pentru a descoperi textul original.\n1. Cifrarea: Co = IV, și recursiv avem Cj =Ek(Cj−1⊕Mj).\n2. Descifrarea: Co =IV,pentru orice j=1,...,t  avem Mj =Cj−1⊕Dk(Cj)",
      "imagine" : "Untitled2",
     
    },
    {
      "title": "Lucrare de laborator Nr.4",
      "laboratorTitle" : "Algoritmul RSA",
      "info" : " Indicații teoretice\n\nIn criptografie, RSA este un algoritm criptografic cu chei publice, primul algoritm utilizat atat pentru criptare, cat si pentru semnatura electronica. Algoritmul a fost dezvoltat in 1977 si publicat in 1978 de Ron Rivest, Adi Shamir si Leonard Adleman la MIT si isi trage numele de la initialele numelor celor trei autori.\nPuterea sa criptografica se bazeaza pe dificultatea problemei factorizarii numerelor intregi, problema la care se reduce criptanaliza RSA si pentru care toti algoritmii de rezolvare cunoscuti au complexitate exponentiala. Exista insa cateva metode de criptanaliza care ocolesc factorizarea efectiva, exploatand maniere eronate de implementare efectiva a schemei de criptare.\n\nFunctionare\nRSA este un algoritm de criptare pe blocuri. Aceasta inseamna ca atat textul clar cat si cel cifrat sunt numere intre 0 si n-1, cu un n ales. Un mesaj de dimensiune mai mare decat log n este impartit in segmente de lungime corespunzatoare, numite blocuri, care sunt cifrate rand pe rand. De asemenea, ca algoritm criptografic cu chei publice, functioneaza pe baza unei perechi de chei legate matematic intre ele: o cheie publica, cunoscuta de toata lumea, si una secreta, necunoscuta decat de detinatorul acesteia.\nGenerarea cheilor\nPerechea de chei se genereaza dupa urmatorii pasi:\n-Se genereaza doua numere prime, de preferat mari, p si q;\n-Se calculeaza n = pq si Φ = (p-1)(q-1)\n-Se alege un intreg aleator e, 1 < e < Φ astfel incat cmmdc(e, Φ) = 1. Perechea (n, e) este cheia publica.\n-Folosind algoritmul lui Euclid extins, se calculeaza intregul d, unicul cu proprietatea ca de ≡ 1mod Φ. (n, d) constituie cheia secreta.\n\nDecizia cu privire la care dintre e si d este cheia publica si care este cea secreta este, din punct de vedere matematic, arbitrara, oricare dintre cele doua numere poate juca oricare dintre roluri. In practica insa, pentru a mari viteza de criptare, si intrucat dintre cele doua numere eeste cel ales arbitrar, e este cheia publica iar valoarea sa este aleasa un numar mic, de regula 3, 17 sau 65537 (216+1). Aceasta conduce la un numar minim de inmultiri, deci la o performanta sporita, deoarece toate aceste numere au doar doua cifre 1 in reprezentarea lor binara.\n\nCriptarea si decriptarea\nPresupunand ca mesajul clar este sub forma unui numar m, mai mic decat n, atunci mesajul cifrat, notat cu c este c = me (mod n) unde e este cheia publica a destinatarului mesajului. Pentru a decripta mesajul, destinatarul isi foloseste cheia sa secreta d, care are proprietatea foarte importanta ca:\nde ≡ 1 mod Φ \n\nAstfel, mesajul clar este recuperat calculand: m = cd (mod n)\n\nOricine poate cripta mesaje cu cheia publica a destinatarului, dar numai acesta din urma poate decripta, deoarece trebuie sa foloseasca cheia sa secreta.\n\nAlgoritmul poate fi folosit si pentru semnatura electronica, folosind cheile invers. Daca o entitate cripteaza un mesaj (sau mai degraba un hash al acestuia) cu cheia sa secreta si ataseaza rezultatul mesajului sau, atunci oricine poate verifica, decriptand cu cheia publica a semnatarului si comparand rezultatul cu mesajul clar (sau cu hash-ul acestuia), ca intr-adevar acea entitate este autorul mesajului.",
     "imagine" : "Untitled3",
      
    },
    {
      "title": "Lucrare de laborator Nr.5",
      "laboratorTitle" : "Dispozitive virtuale protejate prin metode criptografice, standard de protecție (algoritmul RSA)",
      "info" : " Indicații teoretice\n\nIn criptografie, RSA este un algoritm criptografic cu chei publice, primul algoritm utilizat atat pentru criptare, cat si pentru semnatura electronica. Algoritmul a fost dezvoltat in 1977 si publicat in 1978 de Ron Rivest, Adi Shamir si Leonard Adleman la MIT si isi trage numele de la initialele numelor celor trei autori.\nPuterea sa criptografica se bazeaza pe dificultatea problemei factorizarii numerelor intregi, problema la care se reduce criptanaliza RSA si pentru care toti algoritmii de rezolvare cunoscuti au complexitate exponentiala. Exista insa cateva metode de criptanaliza care ocolesc factorizarea efectiva, exploatand maniere eronate de implementare efectiva a schemei de criptare.\n\nFunctionare\nRSA este un algoritm de criptare pe blocuri. Aceasta inseamna ca atat textul clar cat si cel cifrat sunt numere intre 0 si n-1, cu un n ales. Un mesaj de dimensiune mai mare decat log n este impartit in segmente de lungime corespunzatoare, numite blocuri, care sunt cifrate rand pe rand. De asemenea, ca algoritm criptografic cu chei publice, functioneaza pe baza unei perechi de chei legate matematic intre ele: o cheie publica, cunoscuta de toata lumea, si una secreta, necunoscuta decat de detinatorul acesteia.\nGenerarea cheilor\nPerechea de chei se genereaza dupa urmatorii pasi:\n-Se genereaza doua numere prime, de preferat mari, p si q;\n-Se calculeaza n = pq si Φ = (p-1)(q-1)\n-Se alege un intreg aleator e, 1 < e < Φ astfel incat cmmdc(e, Φ) = 1. Perechea (n, e) este cheia publica.\n-Folosind algoritmul lui Euclid extins, se calculeaza intregul d, unicul cu proprietatea ca de ≡ 1mod Φ. (n, d) constituie cheia secreta.\n\nDecizia cu privire la care dintre e si d este cheia publica si care este cea secreta este, din punct de vedere matematic, arbitrara, oricare dintre cele doua numere poate juca oricare dintre roluri. In practica insa, pentru a mari viteza de criptare, si intrucat dintre cele doua numere eeste cel ales arbitrar, e este cheia publica iar valoarea sa este aleasa un numar mic, de regula 3, 17 sau 65537 (216+1). Aceasta conduce la un numar minim de inmultiri, deci la o performanta sporita, deoarece toate aceste numere au doar doua cifre 1 in reprezentarea lor binara.\n\nCriptarea si decriptarea\nPresupunand ca mesajul clar este sub forma unui numar m, mai mic decat n, atunci mesajul cifrat, notat cu c este c = me (mod n) unde e este cheia publica a destinatarului mesajului. Pentru a decripta mesajul, destinatarul isi foloseste cheia sa secreta d, care are proprietatea foarte importanta ca:\nde ≡ 1 mod Φ \n\nAstfel, mesajul clar este recuperat calculand: m = cd (mod n)\n\nOricine poate cripta mesaje cu cheia publica a destinatarului, dar numai acesta din urma poate decripta, deoarece trebuie sa foloseasca cheia sa secreta.\n\nAlgoritmul poate fi folosit si pentru semnatura electronica, folosind cheile invers. Daca o entitate cripteaza un mesaj (sau mai degraba un hash al acestuia) cu cheia sa secreta si ataseaza rezultatul mesajului sau, atunci oricine poate verifica, decriptand cu cheia publica a semnatarului si comparand rezultatul cu mesajul clar (sau cu hash-ul acestuia), ca intr-adevar acea entitate este autorul mesajului.",
     
    },
    {
      "title": "Lucrare de laborator Nr.6",
      "laboratorTitle" : "Securitatea sistemelor de calcul. Organizarea dreptului de acces",
      "info" : " Indicații teoretice\n\nIn criptografie, RSA este un algoritm criptografic cu chei publice, primul algoritm utilizat atat pentru criptare, cat si pentru semnatura electronica. Algoritmul a fost dezvoltat in 1977 si publicat in 1978 de Ron Rivest, Adi Shamir si Leonard Adleman la MIT si isi trage numele de la initialele numelor celor trei autori.\nPuterea sa criptografica se bazeaza pe dificultatea problemei factorizarii numerelor intregi, problema la care se reduce criptanaliza RSA si pentru care toti algoritmii de rezolvare cunoscuti au complexitate exponentiala. Exista insa cateva metode de criptanaliza care ocolesc factorizarea efectiva, exploatand maniere eronate de implementare efectiva a schemei de criptare.\n\nFunctionare\nRSA este un algoritm de criptare pe blocuri. Aceasta inseamna ca atat textul clar cat si cel cifrat sunt numere intre 0 si n-1, cu un n ales. Un mesaj de dimensiune mai mare decat log n este impartit in segmente de lungime corespunzatoare, numite blocuri, care sunt cifrate rand pe rand. De asemenea, ca algoritm criptografic cu chei publice, functioneaza pe baza unei perechi de chei legate matematic intre ele: o cheie publica, cunoscuta de toata lumea, si una secreta, necunoscuta decat de detinatorul acesteia.\nGenerarea cheilor\nPerechea de chei se genereaza dupa urmatorii pasi:\n-Se genereaza doua numere prime, de preferat mari, p si q;\n-Se calculeaza n = pq si Φ = (p-1)(q-1)\n-Se alege un intreg aleator e, 1 < e < Φ astfel incat cmmdc(e, Φ) = 1. Perechea (n, e) este cheia publica.\n-Folosind algoritmul lui Euclid extins, se calculeaza intregul d, unicul cu proprietatea ca de ≡ 1mod Φ. (n, d) constituie cheia secreta.\n\nDecizia cu privire la care dintre e si d este cheia publica si care este cea secreta este, din punct de vedere matematic, arbitrara, oricare dintre cele doua numere poate juca oricare dintre roluri. In practica insa, pentru a mari viteza de criptare, si intrucat dintre cele doua numere eeste cel ales arbitrar, e este cheia publica iar valoarea sa este aleasa un numar mic, de regula 3, 17 sau 65537 (216+1). Aceasta conduce la un numar minim de inmultiri, deci la o performanta sporita, deoarece toate aceste numere au doar doua cifre 1 in reprezentarea lor binara.\n\nCriptarea si decriptarea\nPresupunand ca mesajul clar este sub forma unui numar m, mai mic decat n, atunci mesajul cifrat, notat cu c este c = me (mod n) unde e este cheia publica a destinatarului mesajului. Pentru a decripta mesajul, destinatarul isi foloseste cheia sa secreta d, care are proprietatea foarte importanta ca:\nde ≡ 1 mod Φ \n\nAstfel, mesajul clar este recuperat calculand: m = cd (mod n)\n\nOricine poate cripta mesaje cu cheia publica a destinatarului, dar numai acesta din urma poate decripta, deoarece trebuie sa foloseasca cheia sa secreta.\n\nAlgoritmul poate fi folosit si pentru semnatura electronica, folosind cheile invers. Daca o entitate cripteaza un mesaj (sau mai degraba un hash al acestuia) cu cheia sa secreta si ataseaza rezultatul mesajului sau, atunci oricine poate verifica, decriptand cu cheia publica a semnatarului si comparand rezultatul cu mesajul clar (sau cu hash-ul acestuia), ca intr-adevar acea entitate este autorul mesajului.",
      
    }
  ]
}